{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>MSL Kibble Balance software.</p>"},{"location":"about/license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2024-2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#unreleased","title":"unreleased","text":""},{"location":"equipment/agilent_33500b/","title":"Agilent33500b","text":"<p>Agilent 33500B Waveform Generator.</p>"},{"location":"equipment/agilent_33500b/#kibble.equipment.agilent_33500b.Agilent33500B","title":"Agilent33500B","text":"<pre><code>Agilent33500B(record, *, reset=True, clear=True)\n</code></pre> <p>Agilent 33500B Waveform Generator.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>EquipmentRecord</code> <p>The equipment record.</p> required <code>reset</code> <code>bool</code> <p>Whether to automatically send the <code>*RST</code> command.</p> <code>True</code> <code>clear</code> <code>bool</code> <p>Whether to automatically send the <code>*CLS</code> command.</p> <code>True</code> Source code in <code>src/kibble/equipment/agilent_33500b.py</code> <pre><code>def __init__(self, record: EquipmentRecord, *, reset: bool = True, clear: bool = True) -&gt; None:\n    \"\"\"Communicate with an Agilent 33500B Waveform Generator.\n\n    Args:\n        record: The equipment record.\n        reset: Whether to automatically send the `*RST` command.\n        clear: Whether to automatically send the `*CLS` command.\n    \"\"\"\n    self._cxn = record.connect()\n\n    if reset:\n        self.reset()\n    if clear:\n        self.clear()\n</code></pre>"},{"location":"equipment/agilent_33500b/#kibble.equipment.agilent_33500b.Agilent33500B.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the event registers in all register groups and the error queue.</p> Source code in <code>src/kibble/equipment/agilent_33500b.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears the event registers in all register groups and the error queue.\"\"\"\n    self._cxn.write(\"*CLS\")\n</code></pre>"},{"location":"equipment/agilent_33500b/#kibble.equipment.agilent_33500b.Agilent33500B.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from the waveform generator.</p> Source code in <code>src/kibble/equipment/agilent_33500b.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the waveform generator.\"\"\"\n    self._cxn.disconnect()\n</code></pre>"},{"location":"equipment/agilent_33500b/#kibble.equipment.agilent_33500b.Agilent33500B.output","title":"output","text":"<pre><code>output(*, channel, state)\n</code></pre> <p>Turn the output of a channel on or off.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel number, 1 or 2.</p> required <code>state</code> <code>bool</code> <p>Either on (<code>True</code>) or off (<code>False</code>)</p> required Source code in <code>src/kibble/equipment/agilent_33500b.py</code> <pre><code>def output(self, *, channel: int, state: bool) -&gt; None:\n    \"\"\"Turn the output of a channel on or off.\n\n    Args:\n        channel: The channel number, 1 or 2.\n        state: Either on (`True`) or off (`False`)\n    \"\"\"\n    if channel not in [1, 2]:\n        msg = f\"Channel must be either 1 or 2, got {channel}\"\n        raise ValueError(msg)\n    s = \"ON\" if state else \"OFF\"\n    self._cxn.write(f\"OUTPUT{channel} {s}\")\n</code></pre>"},{"location":"equipment/agilent_33500b/#kibble.equipment.agilent_33500b.Agilent33500B.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the waveform generator to the factory default state.</p> Source code in <code>src/kibble/equipment/agilent_33500b.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the waveform generator to the factory default state.\"\"\"\n    self._cxn.write(\"*RST\")\n</code></pre>"},{"location":"equipment/agilent_33500b/#kibble.equipment.agilent_33500b.Agilent33500B.sine","title":"sine","text":"<pre><code>sine(\n    channel,\n    *,\n    amplitude=3,\n    frequency=1,\n    load=50,\n    offset=0,\n    phase=0,\n    unit=\"VPP\"\n)\n</code></pre> <p>Configure a SINUSOID waveform for a particular channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel number to configure.</p> required <code>amplitude</code> <code>float</code> <p>The amplitude of the waveform.</p> <code>3</code> <code>frequency</code> <code>float</code> <p>The frequency, in Hz, of the waveform.</p> <code>1</code> <code>load</code> <code>float | None</code> <p>The load termination, in Ohms. In the range 1 to 10 kOhm, or <code>None</code> for infinite (High Z).</p> <code>50</code> <code>offset</code> <code>float</code> <p>The offset of the waveform.</p> <code>0</code> <code>phase</code> <code>float</code> <p>The phase, in degrees, of the waveform. In the range 0 to 360 degrees.</p> <code>0</code> <code>unit</code> <code>Literal['VPP', 'VRMS', 'DBM']</code> <p>The <code>amplitude</code> and <code>offset</code> unit.</p> <code>'VPP'</code> Source code in <code>src/kibble/equipment/agilent_33500b.py</code> <pre><code>def sine(\n    self,\n    channel: int,\n    *,\n    amplitude: float = 3,\n    frequency: float = 1,\n    load: float | None = 50,\n    offset: float = 0,\n    phase: float = 0,\n    unit: Literal[\"VPP\", \"VRMS\", \"DBM\"] = \"VPP\",\n) -&gt; None:\n    \"\"\"Configure a SINUSOID waveform for a particular channel.\n\n    Args:\n        channel: The channel number to configure.\n        amplitude: The amplitude of the waveform.\n        frequency: The frequency, in Hz, of the waveform.\n        load: The load termination, in Ohms. In the range 1 to 10 kOhm,\n            or `None` for infinite (High Z).\n        offset: The offset of the waveform.\n        phase: The phase, in degrees, of the waveform. In the range\n            0 to 360 degrees.\n        unit: The `amplitude` and `offset` unit.\n    \"\"\"\n    if channel not in [1, 2]:\n        msg = f\"Channel must be either 1 or 2, got {channel}\"\n        raise ValueError(msg)\n\n    if unit not in [\"VPP\", \"VRMS\", \"DBM\"]:\n        msg = f\"Only VPP, VRMS or DBM units are currently allowed, got {unit}\"\n        raise ValueError(msg)\n\n    if phase &lt; 0 or phase &gt; 360:  # noqa: PLR2004\n        msg = f\"The phase must be between 0 and 360 degrees, got {phase}\"\n        raise ValueError(msg)\n\n    if load is not None and (load &lt; 1 or load &gt; 10e3):  # noqa: PLR2004\n        msg = f\"The terminal load must be between 1 and 10 kOhm or None, got {load}\"\n        raise ValueError(msg)\n\n    self._cxn.write(\n        f\":OUTPUT{channel}:LOAD {load or 'INFINITY'};\"  # OUTPUT must come before SOURCE\n        f\":SOURCE{channel}:FUNCTION SINUSOID;\"\n        f\":SOURCE{channel}:FREQUENCY {frequency};\"\n        f\":SOURCE{channel}:VOLT:UNIT {unit};\"\n        f\":SOURCE{channel}:VOLT {amplitude};\"\n        f\":SOURCE{channel}:VOLT:OFFSET {offset};\"\n        f\":SOURCE{channel}:PHASE {phase};\"\n    )\n    self._check_error()\n</code></pre>"},{"location":"equipment/agilent_3458a/","title":"Agilent3458A","text":"<p>Agilent (or Hewlett Packard or Keysight) 3458A digital multimeter.</p>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A","title":"Agilent3458A","text":"<pre><code>Agilent3458A(record, *, reset=True, clear=True)\n</code></pre> <p>Agilent (or Hewlett Packard or Keysight) 3458A digital multimeter.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>EquipmentRecord</code> <p>The equipment record.</p> required <code>reset</code> <code>bool</code> <p>Whether to automatically send the RESET command.</p> <code>True</code> <code>clear</code> <code>bool</code> <p>Whether to automatically send the GPIB CLEAR command.</p> <code>True</code> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def __init__(self, record: EquipmentRecord, *, reset: bool = True, clear: bool = True) -&gt; None:\n    \"\"\"Communicate with an Agilent (or Hewlett Packard or Keysight) 3458A digital multimeter.\n\n    Args:\n        record: The equipment record.\n        reset: Whether to automatically send the RESET command.\n        clear: Whether to automatically send the GPIB CLEAR command.\n    \"\"\"\n    self._initiate_cmd: str = \"&lt;gets updated in configure&gt;\"\n    self._check_revision: bool = True\n    self._nreadings: int = -1\n\n    record.connection.properties.setdefault(\"termination\", \"\\r\")\n    self._cxn = record.connect()\n\n    if reset:\n        self.reset()\n    if clear:\n        self.clear()\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.abort","title":"abort","text":"<pre><code>abort()\n</code></pre> <p>Abort a measurement in progress.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def abort(self) -&gt; None:\n    \"\"\"Abort a measurement in progress.\"\"\"\n    self.clear()\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clears the event registers in all register groups and the error queue.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears the event registers in all register groups and the error queue.\"\"\"\n    self._cxn.clear()\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.configure","title":"configure","text":"<pre><code>configure(\n    *,\n    function=\"DCV\",\n    range=10,\n    nsamples=10,\n    aperature=0.01,\n    auto_zero=\"ONCE\",\n    trigger=\"IMMEDIATE\",\n    edge=\"FALLING\",\n    ntriggers=1,\n    delay=None\n)\n</code></pre> <p>Configure the digital multimeter.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Literal['DCV']</code> <p>The measurement function. Currently, only DCV is allowed.</p> <code>'DCV'</code> <code>range</code> <code>float</code> <p>The range to use for the measurement.</p> <code>10</code> <code>nsamples</code> <code>int</code> <p>The number of samples to acquire after a trigger event.</p> <code>10</code> <code>aperature</code> <code>float</code> <p>The A/D converter integration time in seconds.</p> <code>0.01</code> <code>auto_zero</code> <code>Literal['ONCE', 'ON', 'OFF']</code> <p>The auto-zero mode. Either ONCE, ON or OFF.</p> <code>'ONCE'</code> <code>trigger</code> <code>Literal['IMMEDIATE', 'BUS', 'EXTERNAL']</code> <p>The trigger mode. Either IMMEDIATE, BUS or EXTERNAL.</p> <code>'IMMEDIATE'</code> <code>edge</code> <code>Literal['FALLING']</code> <p>The trigger edge (only used if <code>trigger</code> is EXTERNAL). Must always be FALLING.</p> <code>'FALLING'</code> <code>ntriggers</code> <code>int</code> <p>The number of triggers that are accepted before returning to the wait-for-trigger state.</p> <code>1</code> <code>delay</code> <code>float | None</code> <p>The number of seconds to wait after a trigger event before acquiring samples. A value of <code>None</code> is equivalent to zero.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The actual A/D converter integration time in seconds.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def configure(  # noqa: C901\n    self,\n    *,\n    function: Literal[\"DCV\"] = \"DCV\",\n    range: float = 10,  # noqa: A002\n    nsamples: int = 10,\n    aperature: float = 0.01,\n    auto_zero: Literal[\"ONCE\", \"ON\", \"OFF\"] = \"ONCE\",\n    trigger: Literal[\"IMMEDIATE\", \"BUS\", \"EXTERNAL\"] = \"IMMEDIATE\",\n    edge: Literal[\"FALLING\"] = \"FALLING\",\n    ntriggers: int = 1,\n    delay: float | None = None,\n) -&gt; float:\n    \"\"\"Configure the digital multimeter.\n\n    Args:\n        function: The measurement function. Currently, only DCV is allowed.\n        range: The range to use for the measurement.\n        nsamples: The number of samples to acquire after a trigger event.\n        aperature: The A/D converter integration time in seconds.\n        auto_zero: The auto-zero mode. Either ONCE, ON or OFF.\n        trigger: The trigger mode. Either IMMEDIATE, BUS or EXTERNAL.\n        edge: The trigger edge (only used if `trigger` is EXTERNAL).\n            Must always be FALLING.\n        ntriggers: The number of triggers that are accepted before\n            returning to the wait-for-trigger state.\n        delay: The number of seconds to wait after a trigger event before\n            acquiring samples. A value of `None` is equivalent to zero.\n\n    Returns:\n        The actual A/D converter integration time in seconds.\n    \"\"\"\n    if function != \"DCV\":\n        msg = f\"Only DCV is implemented, not {function!r}\"\n        raise ValueError(msg)\n\n    if edge != \"FALLING\":\n        msg = f\"Can only trigger on FALLING edge, got {edge!r}\"\n        raise ValueError(msg)\n\n    if auto_zero not in [\"ONCE\", \"ON\", \"OFF\"]:\n        msg = f\"Auto zero must be ONCE, ON or OFF. Got {auto_zero!r}\"\n        raise ValueError(msg)\n\n    if trigger not in [\"IMMEDIATE\", \"BUS\", \"EXTERNAL\"]:\n        msg = f\"Trigger mode must be IMMEDIATE, BUS or EXTERNAL. Got {trigger!r}\"\n        raise ValueError(msg)\n\n    # TARM  -&gt; AUTO, EXT, HOLD,              SGL, SYN\n    # TRIG  -&gt; AUTO, EXT, HOLD, LEVEL, LINE, SGL, SYN\n    # NRDGS -&gt; AUTO, EXT,     , LEVEL, LINE       SYN, TIMER\n    trig_event = \"AUTO\"\n    if trigger == \"IMMEDIATE\":\n        self._initiate_cmd = f\"MEM FIFO;TARM SGL,{ntriggers};MEM OFF\"\n    elif trigger == \"BUS\":\n        self._initiate_cmd = \"TARM HOLD\"\n    else:\n        self._initiate_cmd = f\"MEM FIFO;TARM SGL,{ntriggers};MEM OFF\"\n        trig_event = \"EXT\"\n        if self._check_revision:\n            self._check_revision = False\n            rev = tuple(map(int, self._cxn.query(\"REV?\").split(\",\")))\n            if rev &lt; (9, 2):\n                warnings.warn(\n                    f\"Trigger {trigger} works with firmware revision \"\n                    f\"(9, 2), but revision (6, 2) does not work. \"\n                    f\"The revision is {rev}.\",\n                    stacklevel=2,\n                )\n\n    # Turning the INBUF ON/OFF is required because the GPIB write()\n    # method waits for the count() return value. Therefore, when\n    # self.initiate() or self.trigger() is called, it blocks until a\n    # timeout error is raised or until count() receives a return value.\n    #\n    # Used the NI GPIB-USB-HS+ adapter to communicate with the DMM\n    # to determine this caveat.\n    buff = \"INBUF ON;INBUF OFF;\"\n    self._initiate_cmd = buff + self._initiate_cmd\n\n    fixedz = \"ON\" if function in [\"DCV\", \"OHM\", \"OHMF\"] else \"OFF\"\n\n    self._nreadings = nsamples * ntriggers\n    if self._nreadings &gt; 16_777_215:  # noqa: PLR2004\n        msg = f\"Too many samples requested, {self._nreadings}. Must be &lt;= 16,777,215\"\n        raise ValueError(msg)\n\n    self._cxn.write(\n        f\"TARM HOLD;\"\n        f\"TRIG {trig_event};\"\n        f\"MEM FIFO;\"\n        f\"FUNC {function},{range};\"\n        f\"APER {aperature};\"\n        f\"AZERO {auto_zero};\"\n        f\"NRDGS {nsamples},AUTO;\"\n        f\"DELAY {delay or 0};\"\n        f\"LFREQ LINE;\"\n        f\"FIXEDZ {fixedz};\"\n        f\"MATH OFF;\"\n        f\"DISP OFF;\"\n        # f'MFORMAT DREAL;'  TODO not working yet\n        # f'OFORMAT DREAL;'\n    )\n\n    message = self._cxn.query(\"ERRSTR?\")\n    if not message.startswith(\"0,\"):\n        self._cxn.raise_exception(message)\n\n    return float(self._cxn.query(\"APER?\"))\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Turn the display back on and disconnect from the digital multimeter.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Turn the display back on and disconnect from the digital multimeter.\"\"\"\n    self._cxn.write(\"DISP ON\")\n    self._cxn.disconnect()\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.fetch","title":"fetch","text":"<pre><code>fetch(*, initiate=False)\n</code></pre> <p>Fetch the samples.</p> <p>This is a blocking call and will not return to the calling program until all samples have been acquired.</p> <p>Parameters:</p> Name Type Description Default <code>initiate</code> <code>bool</code> <p>Whether to call <code>initiate()</code> before fetching the samples.</p> <code>False</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The samples.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def fetch(self, *, initiate: bool = False) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Fetch the samples.\n\n    This is a blocking call and will not return to the calling program until\n    all samples have been acquired.\n\n    Args:\n        initiate: Whether to call `initiate()` before fetching the samples.\n\n    Returns:\n        The samples.\n    \"\"\"\n    if initiate:\n        self.initiate()\n\n    while True:\n        try:\n            # From the \"Using the Input Buffer\" section of the manual (page 75):\n            #   When using the input buffer, it may be necessary to know when all\n            #   buffered commands have been executed. The multimeter provides this\n            #   information by setting bit 4 (0b00010000 = 16) in the status register\n            val = self._cxn.serial_poll()\n            if val &amp; 16:\n                break\n        except TypeError:  # serial_poll() received an empty reply\n            pass\n        else:\n            sleep(0.1)\n\n    # From the RMEM documentation on page 336 of manual (Edition 10, March 2023):\n    #   The multimeter assigns a number to each reading in reading memory. The most\n    #   recent reading is assigned the lowest number (1) and the oldest reading has the\n    #   highest number. Numbers are always assigned in this manner regardless of\n    #   whether you're using the FIFO or LIFO mode.\n    # This means that samples is an array of [latest reading, ..., first reading]\n    samples = self._cxn.query(f\"RMEM 1,{self._nreadings},1\")\n    # Want FIFO, so reverse to be [first reading, ..., latest reading]\n    return np.array(samples.split(\",\")[::-1], dtype=np.float64)\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.initiate","title":"initiate","text":"<pre><code>initiate()\n</code></pre> <p>Put the digital multimeter in the wait-for-trigger state (arm the trigger).</p> <p>If the digital multimeter has been configured for trigger mode <code>IMMEDIATE</code>, then the digital multimeter will start acquiring data once this method is called.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def initiate(self) -&gt; None:\n    \"\"\"Put the digital multimeter in the wait-for-trigger state (arm the trigger).\n\n    If the digital multimeter has been configured for trigger mode `IMMEDIATE`,\n    then the digital multimeter will start acquiring data once this method is called.\n    \"\"\"\n    self._cxn.write(self._initiate_cmd)\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the digital multimeter to the factory default state.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the digital multimeter to the factory default state.\"\"\"\n    self._cxn.write(\"RESET;TARM HOLD;\")\n</code></pre>"},{"location":"equipment/agilent_3458a/#kibble.equipment.agilent_3458a.Agilent3458A.trigger","title":"trigger","text":"<pre><code>trigger()\n</code></pre> <p>Send a software trigger.</p> <p>If the digital multimeter has been configured for trigger mode <code>BUS</code>, then the digital multimeter will start acquiring data once this method is called.</p> Source code in <code>src/kibble/equipment/agilent_3458a.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send a software trigger.\n\n    If the digital multimeter has been configured for trigger mode `BUS`, then\n    the digital multimeter will start acquiring data once this method is called.\n    \"\"\"\n    self._cxn.write(\"MEM FIFO;TARM SGL\")\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/","title":"PulseBlaster","text":"<p>SpinCore PulseBlaster.</p>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.Code","title":"Code","text":"<p>               Bases: <code>IntEnum</code></p> <p>Program instruction codes.</p> <p>Attributes:</p> Name Type Description <code>CONTINUE</code> <p>0</p> <code>STOP</code> <p>1</p> <code>LOOP</code> <p>2</p> <code>END_LOOP</code> <p>= 3</p> <code>JSR</code> <p>4</p> <code>RTS</code> <p>5</p> <code>BRANCH</code> <p>6</p> <code>LONG_DELAY</code> <p>7</p> <code>WAIT</code> <p>8</p> <code>RTI</code> <p>9</p>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster","title":"PulseBlaster","text":"<pre><code>PulseBlaster(record)\n</code></pre> <p>               Bases: <code>ConnectionSDK</code></p> <p>SpinCore PulseBlaster.</p> <p>See SpinAPI for the API reference.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>EquipmentRecord</code> <p>The equipment record.</p> required Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def __init__(self, record: EquipmentRecord) -&gt; None:  # noqa: PLR0915\n    \"\"\"Communicate with a SpinCore PulseBlaster.\n\n    See [SpinAPI](http://www.spincore.com/support/spinapi/reference/production/2013-09-25/spinapi_8c.html)\n    for the API reference.\n\n    Args:\n        record: The equipment record.\n    \"\"\"\n    self._connected = False\n    super().__init__(record=record, libtype=\"cdll\")\n\n    # initialize function declarations in spinapi64.dll\n    self.sdk.pb_get_error.argtype = []\n    self.sdk.pb_get_error.restype = c_char_p\n\n    self.sdk.pb_read_status.argtype = []\n    self.sdk.pb_read_status.restype = c_int\n\n    self.sdk.pb_count_boards.argtype = []\n    self.sdk.pb_count_boards.restype = c_int\n\n    self.sdk.pb_select_board.argtype = [c_int]\n    self.sdk.pb_select_board.restype = c_int\n    self.sdk.pb_select_board.errcheck = self._errcheck\n\n    self.sdk.pb_init.argtype = []\n    self.sdk.pb_init.restype = c_int\n    self.sdk.pb_init.errcheck = self._errcheck\n\n    self.sdk.pb_close.argtype = []\n    self.sdk.pb_close.restype = c_int\n    self.sdk.pb_close.errcheck = self._errcheck\n\n    self.sdk.pb_get_version.argtype = []\n    self.sdk.pb_get_version.restype = c_char_p\n\n    self.sdk.pb_get_firmware_id.argtype = []\n    self.sdk.pb_get_firmware_id.restype = c_int\n\n    self.sdk.pb_core_clock.argtype = [c_double]\n    self.sdk.pb_core_clock.restype = None\n\n    self.sdk.pb_start_programming.argtype = [c_int]\n    self.sdk.pb_start_programming.restype = c_int\n    self.sdk.pb_start_programming.errcheck = self._errcheck\n\n    self.sdk.pb_stop_programming.argtype = []\n    self.sdk.pb_stop_programming.restype = c_int\n    self.sdk.pb_stop_programming.errcheck = self._errcheck\n\n    self.sdk.pb_inst_pbonly.argtype = [c_int, c_int, c_int, c_double]\n    self.sdk.pb_inst_pbonly.restype = c_int\n    self.sdk.pb_inst_pbonly.errcheck = self._errcheck\n\n    self.sdk.pb_reset.argtype = []\n    self.sdk.pb_reset.restype = c_int\n    self.sdk.pb_reset.errcheck = self._errcheck\n\n    self.sdk.pb_start.argtype = []\n    self.sdk.pb_start.restype = c_int\n    self.sdk.pb_start.errcheck = self._errcheck\n\n    self.sdk.pb_stop.argtype = []\n    self.sdk.pb_stop.restype = c_int\n    self.sdk.pb_stop.errcheck = self._errcheck\n\n    # configure the default PulseBlaster settings\n    n_boards: int = self.sdk.pb_count_boards()\n    if n_boards &lt;= 0:\n        msg = \"No PulseBlaster boards are available\"\n        raise RuntimeError(msg)\n    if n_boards &gt; 1:\n        msg = f\"{n_boards} PulseBlaster boards are available.\"\n        raise RuntimeError(msg)\n\n    self.sdk.pb_select_board(0)\n    self.sdk.pb_init()\n    self.sdk.pb_core_clock(c_double(100))  # 100 MHz clock frequency\n    self._connected = True\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.add_instruction","title":"add_instruction","text":"<pre><code>add_instruction(\n    *, bits=None, code=Code.CONTINUE, duration=0.001, data=0\n)\n</code></pre> <p>Add an instruction to the <code>PULSE_PROGRAM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>Sequence[int] | None</code> <p>A sequence of bits to set to be TTL high. Each value must be between 0 and 23, inclusive.</p> <code>None</code> <code>code</code> <code>Code | int</code> <p>Operation code for the instruction.</p> <code>CONTINUE</code> <code>duration</code> <code>float</code> <p>Number of seconds to use for this instruction.</p> <code>0.001</code> <code>data</code> <code>int</code> <p>The corresponding data for the <code>code</code> parameter.</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>The address of the created instruction. This address can be</p> <code>int</code> <p>used as the branch address for any branch instructions.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def add_instruction(\n    self,\n    *,\n    bits: Sequence[int] | None = None,\n    code: Code | int = Code.CONTINUE,\n    duration: float = 1e-3,\n    data: int = 0,\n) -&gt; int:\n    \"\"\"Add an instruction to the ``PULSE_PROGRAM``.\n\n    Args:\n        bits: A sequence of bits to set to be TTL high. Each value must\n            be between 0 and 23, inclusive.\n        code: Operation code for the instruction.\n        duration: Number of seconds to use for this instruction.\n        data: The corresponding data for the `code` parameter.\n\n    Returns:\n        The address of the created instruction. This address can be\n        used as the branch address for any branch instructions.\n    \"\"\"\n    flags = 0\n    if bits is not None:\n        for bit in bits:\n            if bit &lt; 0 or bit &gt; 23:  # noqa: PLR2004\n                msg = f\"A bit must be in the range 0..23, got {bit}\"\n                raise ValueError(msg)\n            flags |= 1 &lt;&lt; bit\n\n    return int(self.sdk.pb_inst_pbonly(flags, code, data, c_double(duration * 1e9)))\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from the PulseBlaster board.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the PulseBlaster board.\"\"\"\n    if not self._connected:\n        return\n    self.sdk.pb_close()\n    self._connected = False\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.one_pulse_two_channels","title":"one_pulse_two_channels","text":"<pre><code>one_pulse_two_channels(\n    *,\n    first=0,\n    second=1,\n    width=0.001,\n    delay=0,\n    single=True,\n    period=None\n)\n</code></pre> <p>Configure a new <code>PULSE_PROGRAM</code> that creates one pulse on two channels.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>int</code> <p>The <code>bit#</code> to use for the first pulse.</p> <code>0</code> <code>second</code> <code>int</code> <p>The <code>bit#</code> to use for the second pulse.</p> <code>1</code> <code>width</code> <code>float</code> <p>The width, in seconds, of each pulse.</p> <code>0.001</code> <code>delay</code> <code>float</code> <p>The delay, in seconds, of the second pulse.</p> <code>0</code> <code>single</code> <code>bool</code> <p>Whether the pulses are output in single-shot mode. If enabled, the trigger method must be called before the pulses are output.</p> <code>True</code> <code>period</code> <code>float | None</code> <p>The time, in seconds, between the rising edge of the first pulses. Only used if <code>single</code> is <code>False</code>.</p> <code>None</code> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def one_pulse_two_channels(\n    self,\n    *,\n    first: int = 0,\n    second: int = 1,\n    width: float = 1e-3,\n    delay: float = 0,\n    single: bool = True,\n    period: float | None = None,\n) -&gt; None:\n    \"\"\"Configure a new ``PULSE_PROGRAM`` that creates one pulse on two channels.\n\n    Args:\n        first: The `bit#` to use for the first pulse.\n        second: The `bit#` to use for the second pulse.\n        width: The width, in seconds, of each pulse.\n        delay: The delay, in seconds, of the second pulse.\n        single: Whether the pulses are output in single-shot mode. If enabled,\n            the [trigger][kibble.equipment.spincore_pulseblaster.PulseBlaster.trigger]\n            method must be called before the pulses are output.\n        period: The time, in seconds, between the rising edge of the\n            first pulses. Only used if `single` is `False`.\n    \"\"\"\n    if delay &lt; 0:\n        msg = f\"Only positive delays are allowed, got {delay}\"\n        raise ValueError(msg)\n\n    self.start_programming()\n\n    if delay == 0:\n        total = width\n        start = self.add_instruction(bits=[first, second], duration=width)\n    elif delay &lt; width:\n        d = max(width - delay, self.MIN_DURATION)\n        total = delay + d + delay\n        start = self.add_instruction(bits=[first], duration=delay)\n        self.add_instruction(bits=[first, second], duration=d)\n        self.add_instruction(bits=[second], duration=delay)\n    else:\n        d = max(delay - width, self.MIN_DURATION)\n        total = width + d + width\n        start = self.add_instruction(bits=[first], duration=width)\n        self.add_instruction(duration=d)\n        self.add_instruction(bits=[second], duration=width)\n\n    self.add_instruction(duration=self.MIN_DURATION)\n    if single:\n        self.add_instruction(code=Code.STOP, duration=self.MIN_DURATION)\n    else:\n        if period:\n            if period &lt; total:\n                msg = f\"period ({period}) &lt; total time for pulses ({total})\"\n                raise ValueError(msg)\n            period = max(period - total, self.MIN_DURATION)\n        else:\n            period = self.MIN_DURATION\n        self.add_instruction(code=Code.BRANCH, data=start, duration=period)\n\n    self.stop_programming()\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Stops the output of board and resets the PulseBlaster.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Stops the output of board and resets the PulseBlaster.\"\"\"\n    self.sdk.pb_reset()\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Send a software trigger to the board to start the pulse program.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Send a software trigger to the board to start the pulse program.\"\"\"\n    self.sdk.pb_start()\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.start_programming","title":"start_programming","text":"<pre><code>start_programming()\n</code></pre> <p>Start a <code>PULSE_PROGRAM</code>.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def start_programming(self) -&gt; None:\n    \"\"\"Start a ``PULSE_PROGRAM``.\"\"\"\n    self.sdk.pb_start_programming(0)  # PULSE_PROGRAM = 0\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.status","title":"status","text":"<pre><code>status()\n</code></pre> <p>Read status from the board.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def status(self) -&gt; Status:\n    \"\"\"Read status from the board.\"\"\"\n    return Status(self.sdk.pb_read_status())\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stops output of board.</p> <p>Analog output will return to ground, and TTL outputs will either remain in the same state they were in when the reset command was received or return to ground.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stops output of board.\n\n    Analog output will return to ground, and TTL outputs will either remain in the same\n    state they were in when the reset command was received or return to ground.\n    \"\"\"\n    self.sdk.pb_stop()\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.stop_programming","title":"stop_programming","text":"<pre><code>stop_programming()\n</code></pre> <p>Stop programming the <code>PULSE_PROGRAM</code>, which was started by <code>start_programming()</code>.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def stop_programming(self) -&gt; None:\n    \"\"\"Stop programming the ``PULSE_PROGRAM``, which was started by `start_programming()`.\"\"\"\n    self.sdk.pb_stop_programming()\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.trigger","title":"trigger","text":"<pre><code>trigger()\n</code></pre> <p>Restart the <code>PULSE_PROGRAM</code>.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Restart the ``PULSE_PROGRAM``.\"\"\"\n    self.reset()\n    self.start()\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.PulseBlaster.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Get the version information.</p> <p>Returns:</p> Type Description <code>Version</code> <p>Version information.</p> Source code in <code>src/kibble/equipment/spincore_pulseblaster.py</code> <pre><code>def version(self) -&gt; Version:\n    \"\"\"Get the version information.\n\n    Returns:\n        Version information.\n    \"\"\"\n    fw = self.sdk.pb_get_firmware_id()\n\n    # See: C:\\SpinCore\\SpinAPI\\examples\\General\\pb_read_firmware.c\n    device = (fw &amp; 0xFF00) &gt;&gt; 8\n    revision = fw &amp; 0x00FF\n\n    return Version(software=self.sdk.pb_get_version().decode(), firmware=f\"{device}-{revision}\")\n</code></pre>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.Status","title":"Status","text":"<p>               Bases: <code>IntEnum</code></p> <p>Board status.</p> <p>Attributes:</p> Name Type Description <code>STOPPED</code> <p>1</p> <code>RESET</code> <p>2</p> <code>RUNNING</code> <p>4</p> <code>WAITING</code> <p>8</p> <code>SCANNING</code> <p>16</p>"},{"location":"equipment/spincore_pulseblaster/#kibble.equipment.spincore_pulseblaster.Version","title":"Version  <code>dataclass</code>","text":"<pre><code>Version(software, firmware)\n</code></pre> <p>Board software and firmware version numbers.</p> <p>Attributes:</p> Name Type Description <code>software</code> <code>str</code> <p>Software version number.</p> <code>firmware</code> <code>str</code> <p>Firmware version number.</p>"},{"location":"equipment/swabian_timetagger/","title":"TimeTagger","text":"<p>Swabian TimeTagger equipment.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.Channel","title":"Channel  <code>dataclass</code>","text":"<pre><code>Channel(\n    number,\n    *,\n    deadtime=2000,\n    delay=0,\n    frequency=3000000.0,\n    level=0.5\n)\n</code></pre> <p>A time-tagger channel to measure events.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Channel number. A positive value corresponds to a timestamp event on a rising edge, a negative value corresponds to a timestamp event on a falling edge. See the manual from Swabian Instruments for more details.</p> required <code>deadtime</code> <code>int</code> <p>Dead time (in picoseconds) of the channel. The minimum dead time is defined by the internal clock period (which is 2000 ps for Time Tagger Ultra).</p> <code>2000</code> <code>delay</code> <code>int</code> <p>Additional delay (in picoseconds) to add to the timestamp of every event on this channel.</p> <code>0</code> <code>frequency</code> <code>float</code> <p>The expected maximum number of events (on this channel) per second during a measurement. This value helps to determine the size of the numpy arrays to initialise.</p> <code>3000000.0</code> <code>level</code> <code>float</code> <p>Signal level (in Volts) that, when exceeded, defines an event.</p> <code>0.5</code>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.Displacement","title":"Displacement  <code>dataclass</code>","text":"<pre><code>Displacement(*, beat_freq, folding, wavelength, x, y)\n</code></pre> <p>The result from a displacement measurement.</p> <p>Attributes:</p> Name Type Description <code>beat_freq</code> <code>float</code> <p>Beat frequency, in MHz.</p> <code>folding</code> <code>float</code> <p>Folding factor.</p> <code>wavelength</code> <code>float</code> <p>Wavelength, in nm.</p> <code>x</code> <code>NDArray[float64]</code> <p>Corresponding time (in seconds) of each accumulated change in displacement.</p> <code>y</code> <code>NDArray[float64]</code> <p>Accumulated change in displacement.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.Status","title":"Status  <code>dataclass</code>","text":"<pre><code>Status(*, code, message, success)\n</code></pre> <p>The measurement status.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>StatusCode</code> <p>A status code.</p> required <code>message</code> <code>str</code> <p>A message.</p> required <code>success</code> <code>bool</code> <p>Whether the measurement finished without error.</p> required"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.StatusCode","title":"StatusCode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Status codes for a measurement.</p> <p>Attributes:</p> Name Type Description <code>SUCCESS</code> <p><code>0</code></p> <code>TIMEOUT</code> <p><code>1</code></p> <code>OVERFLOW</code> <p><code>2</code></p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser","title":"TimeIntervalAnalyser","text":"<pre><code>TimeIntervalAnalyser(record=None)\n</code></pre> <p>A time-interval analysis measurement based on start-stop events.</p> <p>The intervals are calculated as stop-start time differences and the time of each interval is relative to:</p> <ul> <li>the timestamp of the first start or stop event if neither gate nor trigger are specified</li> <li>the first edge of the gate pulse, or</li> <li>the trigger signal</li> </ul> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>EquipmentRecord | None</code> <p>The equipment record. See the constructor of TimeTag for more details.</p> <code>None</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def __init__(self, record: EquipmentRecord | None = None) -&gt; None:\n    \"\"\"Perform a time-interval analysis measurement based on start-stop events.\n\n    The intervals are calculated as stop-start time differences and the time of each interval is relative to:\n\n    * the timestamp of the first start or stop event if neither gate nor trigger are specified\n    * the first edge of the gate pulse, or\n    * the trigger signal\n\n    Args:\n        record: The equipment record. See the constructor of\n            [TimeTag][kibble.equipment.swabian_timetagger.TimeTag] for more details.\n    \"\"\"\n    self._record = record\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.configure","title":"configure","text":"<pre><code>configure(\n    *,\n    start,\n    stop,\n    duration=10,\n    gate=None,\n    tagger=None,\n    trigger=None\n)\n</code></pre> <p>Configure the time-interval analysis measurement.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Channel | int</code> <p>The start channel.</p> required <code>stop</code> <code>Channel | int</code> <p>The stop channel.</p> required <code>duration</code> <code>float</code> <p>The expected duration (in seconds) that measurement events will occur. See duration for more details.</p> <code>10</code> <code>gate</code> <code>Channel | int | None</code> <p>The gate channel.</p> <code>None</code> <code>tagger</code> <code>TimeTagger | None</code> <p>A Swabian <code>TimeTagger</code> instance. If not specified, a new instance is created.</p> <code>None</code> <code>trigger</code> <code>Channel | int | None</code> <p>The trigger channel.</p> <code>None</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def configure(\n    self,\n    *,\n    start: Channel | int,\n    stop: Channel | int,\n    duration: float = 10,\n    gate: Channel | int | None = None,\n    tagger: TimeTagger.TimeTagger | None = None,\n    trigger: Channel | int | None = None,\n) -&gt; None:\n    \"\"\"Configure the time-interval analysis measurement.\n\n    Args:\n        start: The start channel.\n        stop: The stop channel.\n        duration: The expected duration (in seconds) that measurement events will occur. See\n            [duration][kibble.equipment.swabian_timetagger.TimeTag.duration] for more details.\n        gate: The gate channel.\n        tagger: A Swabian `TimeTagger` instance. If not specified, a new instance is created.\n        trigger: The trigger channel.\n    \"\"\"\n    if gate is not None and trigger is not None:\n        msg = \"Cannot specify both a gate and a trigger channel\"\n        raise ValueError(msg)\n\n    self._start: Channel = Channel(start) if isinstance(start, int) else start\n    self._stop: Channel = Channel(stop) if isinstance(stop, int) else stop\n    self._gate: Channel | None = None\n    self._trigger: Channel | None = None\n\n    self._measurement: TimeTag\n    if gate is not None:\n        self._gate = Channel(gate, frequency=1) if isinstance(gate, int) else gate\n        self._measurement = TimeTagGated(\n            events=[self._start, self._stop], gate=self._gate, duration=duration, record=self._record, tagger=tagger\n        )\n    elif trigger is not None:\n        self._trigger = Channel(trigger, frequency=1) if isinstance(trigger, int) else trigger\n        self._measurement = TimeTagTriggered(\n            events=[self._start, self._stop],\n            trigger=self._trigger,\n            duration=duration,\n            record=self._record,\n            tagger=tagger,\n        )\n    else:\n        self._measurement = TimeTag(\n            [self._start, self._stop], duration=duration, record=self._record, tagger=tagger\n        )\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.create_channel","title":"create_channel  <code>staticmethod</code>","text":"<pre><code>create_channel(\n    number,\n    *,\n    deadtime=2000,\n    delay=0,\n    frequency=3000000.0,\n    level=0.5\n)\n</code></pre> <p>Create a new channel for a time-tag measurement.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Channel number. A positive value corresponds to a timestamp event on a rising edge, a negative value corresponds to a timestamp event on a falling edge. See the manual from Swabian Instruments for more details.</p> required <code>deadtime</code> <code>int</code> <p>Dead time (in picoseconds) of the channel. The minimum dead time is defined by the internal clock period (which is 2000 ps for Time Tagger Ultra).</p> <code>2000</code> <code>delay</code> <code>int</code> <p>Additional delay (in picoseconds) to add to the timestamp of every event on this channel.</p> <code>0</code> <code>frequency</code> <code>float</code> <p>The expected maximum number of events (on this channel) per second during a measurement.</p> <code>3000000.0</code> <code>level</code> <code>float</code> <p>Signal level (in Volts) that, when exceeded, defines an event.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Channel</code> <p>A time-tag channel.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>@staticmethod\ndef create_channel(\n    number: int, *, deadtime: int = 2000, delay: int = 0, frequency: float = 3e6, level: float = 0.5\n) -&gt; Channel:\n    \"\"\"Create a new channel for a time-tag measurement.\n\n    Args:\n        number: Channel number. A positive value corresponds to a timestamp event on a rising edge,\n            a negative value corresponds to a timestamp event on a falling edge. See the manual from\n            Swabian Instruments for more details.\n        deadtime: Dead time (in picoseconds) of the channel. The minimum dead time is defined\n            by the internal clock period (which is 2000 ps for Time Tagger Ultra).\n        delay: Additional delay (in picoseconds) to add to the timestamp of every event on this channel.\n        frequency: The expected maximum number of events (on this channel) per second during a measurement.\n        level: Signal level (in Volts) that, when exceeded, defines an event.\n\n    Returns:\n        A time-tag channel.\n    \"\"\"\n    return Channel(number, deadtime=deadtime, delay=delay, frequency=frequency, level=level)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Stop all running measurements and release the TimeTagger object from memory.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Stop all running measurements and release the TimeTagger object from memory.\"\"\"\n    self._measurement.disconnect()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.displacement","title":"displacement","text":"<pre><code>displacement(\n    *,\n    beat_freq=None,\n    folding=1.0,\n    subset=None,\n    timeout=None,\n    wavelength=633.24567\n)\n</code></pre> <p>Get the displacement data.</p> <p>Follows the algorithm in XXX. Only considers a start event followed by a stop event as valid data.</p> <p>This is a blocking call and will not return until the measurement finishes or there is an error.</p> <p>Parameters:</p> Name Type Description Default <code>beat_freq</code> <code>float | None</code> <p>Beat frequency, in MHz, of heterodyne beams. If <code>None</code>, calculate the beat frequency as the average difference between neighbouring start timestamps.</p> <code>None</code> <code>folding</code> <code>float</code> <p>Beam path folding number.</p> <code>1.0</code> <code>subset</code> <code>slice | None</code> <p>Slice the data to only use a subset. For example, <code>subset=slice(5, -10)</code> will ignore the first 5 values and the last 10 values from the displacement calculation.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait for the measurement to be done. If <code>None</code>, wait forever.</p> <code>None</code> <code>wavelength</code> <code>float</code> <p>Wavelength, in nanometres, of laser.</p> <code>633.24567</code> <p>Returns:</p> Type Description <code>Displacement</code> <p>The displacement data.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def displacement(\n    self,\n    *,\n    beat_freq: float | None = None,\n    folding: float = 1.0,\n    subset: slice | None = None,\n    timeout: float | None = None,\n    wavelength: float = 633.24567,\n) -&gt; Displacement:\n    \"\"\"Get the displacement data.\n\n    Follows the algorithm in [XXX](). Only considers a start event followed by a stop event as valid data.\n\n    This is a blocking call and will not return until the measurement finishes or there is an error.\n\n    Args:\n        beat_freq: Beat frequency, in MHz, of heterodyne beams. If `None`, calculate the beat\n            frequency as the average difference between neighbouring _start_ timestamps.\n        folding: Beam path folding number.\n        subset: Slice the data to only use a subset. For example, `subset=slice(5, -10)` will\n            ignore the first 5 values and the last 10 values from the displacement calculation.\n        timeout: The maximum number of seconds to wait for the measurement to be done.\n            If `None`, wait forever.\n        wavelength: Wavelength, in nanometres, of laser.\n\n    Returns:\n        The displacement data.\n    \"\"\"\n    x, y = self.time_interval(timeout=timeout)\n    if subset is not None:\n        x, y = x[subset], y[subset]\n\n    if beat_freq is None:\n        channels = self._measurement.channels\n        timestamps = self._measurement.timestamps\n        beat_freq = float(np.mean(1e6 / np.diff(timestamps[channels == self._start.number])))\n\n    phase = np.diff(y * 2.0 * np.pi * beat_freq * 1e6)\n\n    # If change in phase exceeds pi, assume 0/2*pi was crossed\n    phase = np.where(np.abs(phase) &gt; np.pi, phase - np.sign(phase) * 2.0 * np.pi, phase)\n\n    # Accumulate change in displacement with time\n    y_displacement = np.cumsum(phase * (wavelength * 1e-9) / (4.0 * np.pi * folding))\n    return Displacement(\n        beat_freq=beat_freq,\n        folding=folding,\n        wavelength=wavelength,\n        x=x[1:],\n        y=y_displacement,\n    )\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.start","title":"start","text":"<pre><code>start(*, delay=0.05)\n</code></pre> <p>Start a measurement.</p> <p>This method does not block the calling routine. It will return after <code>delay</code> seconds.</p> <p>Parameters:</p> Name Type Description Default <code>delay</code> <code>float</code> <p>The number of seconds to wait before returning to the calling program. A delay is required for the TimeTagger firmware to process the start request.</p> <code>0.05</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def start(self, *, delay: float = 0.05) -&gt; None:\n    \"\"\"Start a measurement.\n\n    This method does not block the calling routine. It will return after `delay` seconds.\n\n    Args:\n        delay: The number of seconds to wait before returning to the calling program.\n            A delay is required for the TimeTagger firmware to process the start request.\n    \"\"\"\n    self._measurement.start()\n    sleep(delay)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the measurement.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the measurement.\"\"\"\n    self._measurement.stop()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeIntervalAnalyser.time_interval","title":"time_interval","text":"<pre><code>time_interval(*, timeout=None)\n</code></pre> <p>Get the time-interval data.</p> <p>Only considers a start event followed by a stop event as valid data.</p> <p>This is a blocking call and will not return until the measurement finishes or there is an error.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait for the measurement to be done. If <code>None</code>, wait forever.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[NDArray[float64], NDArray[float64]]</code> <p>A tuple of two numpy array's (time, interval).</p> <ul> <li><code>time</code>: Time (in seconds) of <code>start</code> events relative to the first timestamp event.</li> <li><code>interval</code>: Difference (in seconds) between the <code>stop</code> and <code>start</code>  timestamps.</li> </ul> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def time_interval(self, *, timeout: float | None = None) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Get the time-interval data.\n\n    Only considers a start event followed by a stop event as valid data.\n\n    This is a blocking call and will not return until the measurement finishes or there is an error.\n\n    Args:\n        timeout: The maximum number of seconds to wait for the measurement to be done.\n            If `None`, wait forever.\n\n    Returns:\n        A tuple of two numpy array's (time, interval).\n\n            * `time`: Time (in seconds) of `start` events relative to the first timestamp event.\n            * `interval`: Difference (in seconds) between the `stop` and `start`  timestamps.\n    \"\"\"\n    status = self._measurement.wait(timeout=timeout)\n    if not status.success:\n        raise RuntimeError(status.message)\n\n    start = self._start.number\n    stop = self._stop.number\n    channels = self._measurement.channels\n    timestamps = self._measurement.timestamps\n\n    if channels.size == 0:\n        if self._gate is not None:\n            msg = \"No events detected, try to increase the width of the gate pulse\"\n        else:\n            msg = \"No events detected, try to increase the duration time of the measurement\"\n        raise RuntimeError(msg)\n\n    if self._gate is not None:\n        if channels[0] != self._gate.number:\n            msg = f\"The first channel, {channels[0]}, is not equal to the gate channel, {self._gate.number}\"\n            raise RuntimeError(msg)\n        if channels[-1] != -self._gate.number:\n            msg = f\"The last channel, {channels[0]}, is not equal to the gate channel, {-self._gate.number}\"\n            raise RuntimeError(msg)\n\n    if self._trigger is not None and channels[0] != self._trigger.number:\n        msg = f\"The first channel, {channels[0]}, is not equal to the trigger channel, {self._trigger.number}\"\n        raise RuntimeError(msg)\n\n    # arbitrarily chose to append 100 since it cannot be a valid TimeTagger channel but it is a valid int8\n    diff = np.diff(channels, append=100)\n\n    # must also check \"channels==start\" in addition to the \"stop-start\" difference since \"start-trigger\",\n    # \"stop-trigger\", \"abs(start-gate)\", \"abs(stop-gate)\" may also equal the \"stop-start\" difference\n    start_indices = np.logical_and(channels == start, diff == stop - start)\n    stop_indices = np.roll(start_indices, 1)\n\n    t1 = timestamps[start_indices]\n    t2 = timestamps[stop_indices]\n    if t1.size == 0 or t2.size == 0:\n        return np.array([], dtype=np.float64), np.array([], dtype=np.float64)\n\n    intervals = 1e-12 * (t1 - t2).astype(np.float64)\n    times = 1e-12 * (t1 - timestamps[0]).astype(np.float64)\n    return times, intervals\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag","title":"TimeTag","text":"<pre><code>TimeTag(channels, *, duration=10, record=None, tagger=None)\n</code></pre> <p>               Bases: <code>CustomMeasurement</code></p> <p>Custom TimeTagger measurement.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Sequence[Channel]</code> <p>The channels involved in the measurement.</p> required <code>duration</code> <code>float</code> <p>The expected duration (in seconds) that measurement events will occur. For gated and triggered measurements, the time before the rising edge of the gate/trigger pulse shall not be included in the duration.</p> <code>10</code> <code>record</code> <code>EquipmentRecord | None</code> <p>The equipment record. If specified and <code>tagger</code> is not specified, then the serial number in the <code>record</code> will be used to connect to a specific <code>TimeTagger</code>. A resolution key-value pair in record.connection.properties may be used to set the resolution of the <code>TimeTagger</code> (i.e., for HighResA set <code>resolution=1</code>).</p> <code>None</code> <code>tagger</code> <code>TimeTagger | None</code> <p>A Swabian <code>TimeTagger</code> instance. If not specified, a new instance is created.</p> <code>None</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def __init__(\n    self,\n    channels: Sequence[Channel],\n    *,\n    duration: float = 10,\n    record: EquipmentRecord | None = None,\n    tagger: TimeTagger.TimeTagger | None = None,\n) -&gt; None:\n    \"\"\"Perform a time-tag measurement.\n\n    Args:\n        channels: The channels involved in the measurement.\n        duration: The expected duration (in seconds) that measurement events will occur.\n            For gated and triggered measurements, the time before the rising edge of the\n            gate/trigger pulse shall not be included in the duration.\n        record: The equipment record. If specified and `tagger` is not specified, then the\n            serial number in the `record` will be used to connect to a specific `TimeTagger`.\n            A _resolution_ key-value pair in\n            [record.connection.properties][msl.equipment.record_types.ConnectionRecord.properties]\n            may be used to set the resolution of the `TimeTagger` (i.e., for HighResA set `resolution=1`).\n        tagger: A Swabian `TimeTagger` instance. If not specified, a new instance is created.\n    \"\"\"\n    self._is_array_overflow = False  # overflow on the numpy array?\n    self._is_tagger_overflow = False  # overflow on the time-tagger?\n    self._is_done = False  # measurement done?\n    self._events = 0  # number of events that were processed\n    self._begin_time = 0  # the begin_time (in ps) of the first call to self.process()\n\n    self._free_tagger = False\n    if not tagger:\n        if record is None:\n            serial, resolution = \"\", 0\n        else:\n            serial = record.serial\n            if record.connection is None:\n                resolution = TimeTagger.Resolution.Standard\n            else:\n                resolution = record.connection.properties.get(\"resolution\", TimeTagger.Resolution.Standard)\n        tagger = TimeTagger.createTimeTagger(serial=serial, resolution=resolution)\n        self._free_tagger = True\n    self._tagger: TimeTagger.TimeTagger = tagger\n    super().__init__(tagger)\n\n    self._input_channels = channels\n    for channel in channels:\n        tagger.setTriggerLevel(channel.number, channel.level)\n        tagger.setInputDelay(channel.number, channel.delay)\n        tagger.setDeadtime(channel.number, channel.deadtime)\n        self.register_channel(channel.number)\n\n    self._channels: NDArray[np.int8]\n    self._timestamps: NDArray[np.int64]\n    self.duration = duration\n\n    self.finalize_init()  # Must be called when done configuring a CustomMeasurement\n    self.stop()  # However, finalize_init() automatically starts a measurement (which also calls self.on_start())\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.channels","title":"channels  <code>property</code>","text":"<pre><code>channels\n</code></pre> <p>Return the channel number for every event.</p> <p>Returns:</p> Type Description <code>NDArray[int8]</code> <p>A 1D numpy array of channel numbers.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.duration","title":"duration  <code>property</code> <code>writable</code>","text":"<pre><code>duration\n</code></pre> <p>The expected number of seconds that a measurement will take.</p> <p>The duration shall not include the time before a gate nor a trigger event (if used). Only the expected duration of the measurement of interest need be specified.</p> <p>For a triggered measurement, the <code>duration</code> corresponds to the measurement time after the trigger edge. For a gated measurement, the <code>duration</code> corresponds to the width of the gate pulse. The <code>duration</code> value also helps to determine the size of the numpy arrays to initialise.</p> <p>Returns:</p> Type Description <code>float</code> <p>The measurement duration.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.timestamps","title":"timestamps  <code>property</code>","text":"<pre><code>timestamps\n</code></pre> <p>Return the timestamp for every event.</p> <p>Returns:</p> Type Description <code>NDArray[int64]</code> <p>A 1D numpy array of timestamps.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.configure_data_stream","title":"configure_data_stream","text":"<pre><code>configure_data_stream(*, events=131072, latency=20)\n</code></pre> <p>Configure the size of the data stream.</p> <p>Depending on which of the two parameters is exceeded first, the number of events to <code>process()</code> in the data stream is adjusted accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>int</code> <p>Maximum number of events before <code>process()</code> is called (256 - 32M).</p> <code>131072</code> <code>latency</code> <code>int</code> <p>Maximum latency (in milliseconds) before <code>process</code> is called (1 to 10000).</p> <code>20</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def configure_data_stream(self, *, events: int = 131072, latency: int = 20) -&gt; None:\n    \"\"\"Configure the size of the data stream.\n\n    Depending on which of the two parameters is exceeded first, the number of\n    events to `process()` in the data stream is adjusted accordingly.\n\n    Args:\n        events: Maximum number of events before `process()` is called (256 - 32M).\n        latency: Maximum latency (in milliseconds) before `process` is called (1 to 10000).\n    \"\"\"\n    self._tagger.setStreamBlockSize(events, latency)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.create_channel","title":"create_channel  <code>staticmethod</code>","text":"<pre><code>create_channel(\n    number,\n    *,\n    deadtime=2000,\n    delay=0,\n    frequency=3000000.0,\n    level=0.5\n)\n</code></pre> <p>Create a new channel for a time-tag measurement.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Channel number. A positive value corresponds to a timestamp event on a rising edge, a negative value corresponds to a timestamp event on a falling edge. See the manual from Swabian Instruments for more details.</p> required <code>deadtime</code> <code>int</code> <p>Dead time (in picoseconds) of the channel. The minimum dead time is defined by the internal clock period (which is 2000 ps for Time Tagger Ultra).</p> <code>2000</code> <code>delay</code> <code>int</code> <p>Additional delay (in picoseconds) to add to the timestamp of every event on this channel.</p> <code>0</code> <code>frequency</code> <code>float</code> <p>The expected maximum number of events (on this channel) per second during a measurement.</p> <code>3000000.0</code> <code>level</code> <code>float</code> <p>Signal level (in Volts) that, when exceeded, defines an event.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Channel</code> <p>A time-tag channel.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>@staticmethod\ndef create_channel(\n    number: int, *, deadtime: int = 2000, delay: int = 0, frequency: float = 3e6, level: float = 0.5\n) -&gt; Channel:\n    \"\"\"Create a new channel for a time-tag measurement.\n\n    Args:\n        number: Channel number. A positive value corresponds to a timestamp event on a rising edge,\n            a negative value corresponds to a timestamp event on a falling edge. See the manual from\n            Swabian Instruments for more details.\n        deadtime: Dead time (in picoseconds) of the channel. The minimum dead time is defined\n            by the internal clock period (which is 2000 ps for Time Tagger Ultra).\n        delay: Additional delay (in picoseconds) to add to the timestamp of every event on this channel.\n        frequency: The expected maximum number of events (on this channel) per second during a measurement.\n        level: Signal level (in Volts) that, when exceeded, defines an event.\n\n    Returns:\n        A time-tag channel.\n    \"\"\"\n    return Channel(number, deadtime=deadtime, delay=delay, frequency=frequency, level=level)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Stop all running measurements and release the TimeTagger object from memory.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Stop all running measurements and release the TimeTagger object from memory.\"\"\"\n    if not hasattr(self, \"_free_tagger\") or not hasattr(self, \"this\"):\n        return\n\n    self.stop()\n    if self._free_tagger:\n        TimeTagger.freeTimeTagger(self._tagger)\n        self._free_tagger = False\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.done","title":"done","text":"<pre><code>done()\n</code></pre> <p>Check if the measurement is done.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the measurement is done.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"Check if the measurement is done.\n\n    Returns:\n        Whether the measurement is done.\n    \"\"\"\n    return self._is_done\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start a measurement.</p> <p>This method does not block the calling routine. It will return as soon as the measurement is running.</p> See Also <p>wait</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start a measurement.\n\n    This method does not block the calling routine. It will return as\n    soon as the measurement is running.\n\n    See Also:\n        [wait][kibble.equipment.swabian_timetagger.TimeTag.wait]\n    \"\"\"\n    self._is_array_overflow = False\n    self._is_tagger_overflow = False\n    self._is_done = False\n    self._begin_time = -1\n    self._events = 0\n    self._tagger.clearOverflows()\n    self.clear()\n    super().start()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop a measurement.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop a measurement.\"\"\"\n    # Implemented so that this method appears in the documentation\n    super().stop()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.tagger","title":"tagger","text":"<pre><code>tagger()\n</code></pre> <p>Return the time-tagger instance.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def tagger(self) -&gt; TimeTagger.TimeTagger:\n    \"\"\"Return the time-tagger instance.\"\"\"\n    return self._tagger\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTag.wait","title":"wait","text":"<pre><code>wait(*, timeout=None)\n</code></pre> <p>Wait until the measurement is done.</p> <p>This is a blocking call and will not return until the measurement finishes or there is an error.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait for the measurement to be done. If <code>None</code>, wait forever.</p> <code>None</code> <p>Returns:</p> Type Description <code>Status</code> <p>The status when the measurement finished.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def wait(self, *, timeout: float | None = None) -&gt; Status:\n    \"\"\"Wait until the measurement is done.\n\n    This is a blocking call and will not return until the measurement finishes or there is an error.\n\n    Args:\n        timeout: The maximum number of seconds to wait for the measurement to be done.\n            If `None`, wait forever.\n\n    Returns:\n        The status when the measurement finished.\n    \"\"\"\n    t0 = perf_counter()\n    while True:\n        if self.done():\n            self.stop()\n            return Status(code=StatusCode.SUCCESS, message=\"Success\", success=True)\n\n        if (timeout is not None) and (perf_counter() - t0 &gt; timeout):\n            self.stop()\n            return Status(\n                code=StatusCode.TIMEOUT,\n                message=f\"Time-tag measurement timeout after {timeout} seconds\",\n                success=False,\n            )\n\n        if self._is_tagger_overflow:\n            self.stop()\n            return Status(code=StatusCode.OVERFLOW, message=\"TimeTagger has a buffer overflow\", success=False)\n\n        if self._is_array_overflow:\n            self.stop()\n            return Status(\n                code=StatusCode.OVERFLOW,\n                message=\"Buffered numpy array too small. Try one (or more) of the following:\\n\"\n                \"- Increase the expected frequency of a channel\\n\"\n                \"- Check that the voltage level for each channel is appropriate for the noise in the signal\\n\"\n                \"- For a gated measurement, increase the expected measurement duration\",\n                success=False,\n            )\n\n        sleep(0.01)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated","title":"TimeTagGated","text":"<pre><code>TimeTagGated(\n    *, events, gate, duration=10, record=None, tagger=None\n)\n</code></pre> <p>               Bases: <code>TimeTag</code></p> <p>A gated time-tag measurement.</p> <p>Events are considered valid only during the <code>gate</code> pulse.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Sequence[Channel]</code> <p>The channel(s) that contain the events to measure.</p> required <code>gate</code> <code>Channel</code> <p>The gate channel. The frequency attribute is ignored.</p> required <code>duration</code> <code>float</code> <p>The expected duration (in seconds) that measurement events will occur. See duration for more details.</p> <code>10</code> <code>record</code> <code>EquipmentRecord | None</code> <p>The equipment record. See the constructor of TimeTag for more details.</p> <code>None</code> <code>tagger</code> <code>TimeTagger | None</code> <p>A Swabian <code>TimeTagger</code> instance. If not specified, a new instance is created.</p> <code>None</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def __init__(\n    self,\n    *,\n    events: Sequence[Channel],\n    gate: Channel,\n    duration: float = 10,\n    record: EquipmentRecord | None = None,\n    tagger: TimeTagger.TimeTagger | None = None,\n) -&gt; None:\n    \"\"\"Perform a gated measurement.\n\n    Events are considered valid only during the `gate` pulse.\n\n    Args:\n        events: The channel(s) that contain the events to measure.\n        gate: The gate channel. The [frequency][kibble.equipment.swabian_timetagger.Channel] attribute is ignored.\n        duration: The expected duration (in seconds) that measurement events will occur. See\n            [duration][kibble.equipment.swabian_timetagger.TimeTag.duration] for more details.\n        record: The equipment record. See the constructor of\n            [TimeTag][kibble.equipment.swabian_timetagger.TimeTag] for more details.\n        tagger: A Swabian `TimeTagger` instance. If not specified, a new instance is created.\n    \"\"\"\n    self._is_gated = False\n    self._gate_channel = gate.number\n\n    channels = list(events)\n    channels.append(Channel(gate.number, deadtime=gate.deadtime, level=gate.level, frequency=1))\n    channels.append(Channel(-gate.number, deadtime=gate.deadtime, level=gate.level, frequency=1))\n    super().__init__(channels, duration=duration, record=record, tagger=tagger)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.channels","title":"channels  <code>property</code>","text":"<pre><code>channels\n</code></pre> <p>Return the channel number for every event.</p> <p>Returns:</p> Type Description <code>NDArray[int8]</code> <p>A 1D numpy array of channel numbers.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.duration","title":"duration  <code>property</code> <code>writable</code>","text":"<pre><code>duration\n</code></pre> <p>The expected number of seconds that a measurement will take.</p> <p>The duration shall not include the time before a gate nor a trigger event (if used). Only the expected duration of the measurement of interest need be specified.</p> <p>For a triggered measurement, the <code>duration</code> corresponds to the measurement time after the trigger edge. For a gated measurement, the <code>duration</code> corresponds to the width of the gate pulse. The <code>duration</code> value also helps to determine the size of the numpy arrays to initialise.</p> <p>Returns:</p> Type Description <code>float</code> <p>The measurement duration.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.timestamps","title":"timestamps  <code>property</code>","text":"<pre><code>timestamps\n</code></pre> <p>Return the timestamp for every event.</p> <p>Returns:</p> Type Description <code>NDArray[int64]</code> <p>A 1D numpy array of timestamps.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.configure_data_stream","title":"configure_data_stream","text":"<pre><code>configure_data_stream(*, events=131072, latency=20)\n</code></pre> <p>Configure the size of the data stream.</p> <p>Depending on which of the two parameters is exceeded first, the number of events to <code>process()</code> in the data stream is adjusted accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>int</code> <p>Maximum number of events before <code>process()</code> is called (256 - 32M).</p> <code>131072</code> <code>latency</code> <code>int</code> <p>Maximum latency (in milliseconds) before <code>process</code> is called (1 to 10000).</p> <code>20</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def configure_data_stream(self, *, events: int = 131072, latency: int = 20) -&gt; None:\n    \"\"\"Configure the size of the data stream.\n\n    Depending on which of the two parameters is exceeded first, the number of\n    events to `process()` in the data stream is adjusted accordingly.\n\n    Args:\n        events: Maximum number of events before `process()` is called (256 - 32M).\n        latency: Maximum latency (in milliseconds) before `process` is called (1 to 10000).\n    \"\"\"\n    self._tagger.setStreamBlockSize(events, latency)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.create_channel","title":"create_channel  <code>staticmethod</code>","text":"<pre><code>create_channel(\n    number,\n    *,\n    deadtime=2000,\n    delay=0,\n    frequency=3000000.0,\n    level=0.5\n)\n</code></pre> <p>Create a new channel for a time-tag measurement.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Channel number. A positive value corresponds to a timestamp event on a rising edge, a negative value corresponds to a timestamp event on a falling edge. See the manual from Swabian Instruments for more details.</p> required <code>deadtime</code> <code>int</code> <p>Dead time (in picoseconds) of the channel. The minimum dead time is defined by the internal clock period (which is 2000 ps for Time Tagger Ultra).</p> <code>2000</code> <code>delay</code> <code>int</code> <p>Additional delay (in picoseconds) to add to the timestamp of every event on this channel.</p> <code>0</code> <code>frequency</code> <code>float</code> <p>The expected maximum number of events (on this channel) per second during a measurement.</p> <code>3000000.0</code> <code>level</code> <code>float</code> <p>Signal level (in Volts) that, when exceeded, defines an event.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Channel</code> <p>A time-tag channel.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>@staticmethod\ndef create_channel(\n    number: int, *, deadtime: int = 2000, delay: int = 0, frequency: float = 3e6, level: float = 0.5\n) -&gt; Channel:\n    \"\"\"Create a new channel for a time-tag measurement.\n\n    Args:\n        number: Channel number. A positive value corresponds to a timestamp event on a rising edge,\n            a negative value corresponds to a timestamp event on a falling edge. See the manual from\n            Swabian Instruments for more details.\n        deadtime: Dead time (in picoseconds) of the channel. The minimum dead time is defined\n            by the internal clock period (which is 2000 ps for Time Tagger Ultra).\n        delay: Additional delay (in picoseconds) to add to the timestamp of every event on this channel.\n        frequency: The expected maximum number of events (on this channel) per second during a measurement.\n        level: Signal level (in Volts) that, when exceeded, defines an event.\n\n    Returns:\n        A time-tag channel.\n    \"\"\"\n    return Channel(number, deadtime=deadtime, delay=delay, frequency=frequency, level=level)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Stop all running measurements and release the TimeTagger object from memory.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Stop all running measurements and release the TimeTagger object from memory.\"\"\"\n    if not hasattr(self, \"_free_tagger\") or not hasattr(self, \"this\"):\n        return\n\n    self.stop()\n    if self._free_tagger:\n        TimeTagger.freeTimeTagger(self._tagger)\n        self._free_tagger = False\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.done","title":"done","text":"<pre><code>done()\n</code></pre> <p>Check if the measurement is done.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the measurement is done.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"Check if the measurement is done.\n\n    Returns:\n        Whether the measurement is done.\n    \"\"\"\n    return self._is_done\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start a measurement.</p> <p>This method does not block the calling routine. It will return as soon as the measurement is running.</p> See Also <p>wait</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start a measurement.\n\n    This method does not block the calling routine. It will return as\n    soon as the measurement is running.\n\n    See Also:\n        [wait][kibble.equipment.swabian_timetagger.TimeTag.wait]\n    \"\"\"\n    self._is_array_overflow = False\n    self._is_tagger_overflow = False\n    self._is_done = False\n    self._begin_time = -1\n    self._events = 0\n    self._tagger.clearOverflows()\n    self.clear()\n    super().start()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop a measurement.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop a measurement.\"\"\"\n    # Implemented so that this method appears in the documentation\n    super().stop()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.tagger","title":"tagger","text":"<pre><code>tagger()\n</code></pre> <p>Return the time-tagger instance.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def tagger(self) -&gt; TimeTagger.TimeTagger:\n    \"\"\"Return the time-tagger instance.\"\"\"\n    return self._tagger\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagGated.wait","title":"wait","text":"<pre><code>wait(*, timeout=None)\n</code></pre> <p>Wait until the measurement is done.</p> <p>This is a blocking call and will not return until the measurement finishes or there is an error.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait for the measurement to be done. If <code>None</code>, wait forever.</p> <code>None</code> <p>Returns:</p> Type Description <code>Status</code> <p>The status when the measurement finished.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def wait(self, *, timeout: float | None = None) -&gt; Status:\n    \"\"\"Wait until the measurement is done.\n\n    This is a blocking call and will not return until the measurement finishes or there is an error.\n\n    Args:\n        timeout: The maximum number of seconds to wait for the measurement to be done.\n            If `None`, wait forever.\n\n    Returns:\n        The status when the measurement finished.\n    \"\"\"\n    t0 = perf_counter()\n    while True:\n        if self.done():\n            self.stop()\n            return Status(code=StatusCode.SUCCESS, message=\"Success\", success=True)\n\n        if (timeout is not None) and (perf_counter() - t0 &gt; timeout):\n            self.stop()\n            return Status(\n                code=StatusCode.TIMEOUT,\n                message=f\"Time-tag measurement timeout after {timeout} seconds\",\n                success=False,\n            )\n\n        if self._is_tagger_overflow:\n            self.stop()\n            return Status(code=StatusCode.OVERFLOW, message=\"TimeTagger has a buffer overflow\", success=False)\n\n        if self._is_array_overflow:\n            self.stop()\n            return Status(\n                code=StatusCode.OVERFLOW,\n                message=\"Buffered numpy array too small. Try one (or more) of the following:\\n\"\n                \"- Increase the expected frequency of a channel\\n\"\n                \"- Check that the voltage level for each channel is appropriate for the noise in the signal\\n\"\n                \"- For a gated measurement, increase the expected measurement duration\",\n                success=False,\n            )\n\n        sleep(0.01)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered","title":"TimeTagTriggered","text":"<pre><code>TimeTagTriggered(\n    *,\n    events,\n    trigger,\n    duration=10,\n    record=None,\n    tagger=None\n)\n</code></pre> <p>               Bases: <code>TimeTag</code></p> <p>A triggered time-tag measurement.</p> <p>Events are considered valid after the trigger signal and until the specified measurement duration.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>Sequence[Channel]</code> <p>The channel(s) that contain the events to measure.</p> required <code>trigger</code> <code>Channel</code> <p>The trigger channel. The frequency attribute is ignored.</p> required <code>duration</code> <code>float</code> <p>The expected duration (in seconds) that measurement events will occur. See duration for more details.</p> <code>10</code> <code>record</code> <code>EquipmentRecord | None</code> <p>The equipment record. See the constructor of TimeTag for more details.</p> <code>None</code> <code>tagger</code> <code>TimeTagger | None</code> <p>A Swabian <code>TimeTagger</code> instance. If not specified, a new instance is created.</p> <code>None</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def __init__(\n    self,\n    *,\n    events: Sequence[Channel],\n    trigger: Channel,\n    duration: float = 10,\n    record: EquipmentRecord | None = None,\n    tagger: TimeTagger.TimeTagger | None = None,\n) -&gt; None:\n    \"\"\"Perform a triggered measurement.\n\n    Events are considered valid after the trigger signal and until the specified measurement duration.\n\n    Args:\n        events: The channel(s) that contain the events to measure.\n        trigger: The trigger channel. The [frequency][kibble.equipment.swabian_timetagger.Channel]\n            attribute is ignored.\n        duration: The expected duration (in seconds) that measurement events will occur. See\n            [duration][kibble.equipment.swabian_timetagger.TimeTag.duration] for more details.\n        record: The equipment record. See the constructor of\n            [TimeTag][kibble.equipment.swabian_timetagger.TimeTag] for more details.\n        tagger: A Swabian `TimeTagger` instance. If not specified, a new instance is created.\n    \"\"\"\n    self._is_triggered: bool = False  # whether the TRIGGER event was received\n    self._done_time: int = -1  # timestamp, in picoseconds, when the measurement is done\n    self._trigger_channel: int = trigger.number\n\n    channels = list(events)\n    channels.append(\n        Channel(\n            trigger.number,\n            deadtime=trigger.deadtime,\n            level=trigger.level,\n            frequency=1,\n        )\n    )\n    super().__init__(channels, duration=duration, record=record, tagger=tagger)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.channels","title":"channels  <code>property</code>","text":"<pre><code>channels\n</code></pre> <p>Return the channel number for every event.</p> <p>Returns:</p> Type Description <code>NDArray[int8]</code> <p>A 1D numpy array of channel numbers.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.duration","title":"duration  <code>property</code> <code>writable</code>","text":"<pre><code>duration\n</code></pre> <p>The expected number of seconds that a measurement will take.</p> <p>The duration shall not include the time before a gate nor a trigger event (if used). Only the expected duration of the measurement of interest need be specified.</p> <p>For a triggered measurement, the <code>duration</code> corresponds to the measurement time after the trigger edge. For a gated measurement, the <code>duration</code> corresponds to the width of the gate pulse. The <code>duration</code> value also helps to determine the size of the numpy arrays to initialise.</p> <p>Returns:</p> Type Description <code>float</code> <p>The measurement duration.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.timestamps","title":"timestamps  <code>property</code>","text":"<pre><code>timestamps\n</code></pre> <p>Return the timestamp for every event.</p> <p>Returns:</p> Type Description <code>NDArray[int64]</code> <p>A 1D numpy array of timestamps.</p>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.configure_data_stream","title":"configure_data_stream","text":"<pre><code>configure_data_stream(*, events=131072, latency=20)\n</code></pre> <p>Configure the size of the data stream.</p> <p>Depending on which of the two parameters is exceeded first, the number of events to <code>process()</code> in the data stream is adjusted accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>int</code> <p>Maximum number of events before <code>process()</code> is called (256 - 32M).</p> <code>131072</code> <code>latency</code> <code>int</code> <p>Maximum latency (in milliseconds) before <code>process</code> is called (1 to 10000).</p> <code>20</code> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def configure_data_stream(self, *, events: int = 131072, latency: int = 20) -&gt; None:\n    \"\"\"Configure the size of the data stream.\n\n    Depending on which of the two parameters is exceeded first, the number of\n    events to `process()` in the data stream is adjusted accordingly.\n\n    Args:\n        events: Maximum number of events before `process()` is called (256 - 32M).\n        latency: Maximum latency (in milliseconds) before `process` is called (1 to 10000).\n    \"\"\"\n    self._tagger.setStreamBlockSize(events, latency)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.create_channel","title":"create_channel  <code>staticmethod</code>","text":"<pre><code>create_channel(\n    number,\n    *,\n    deadtime=2000,\n    delay=0,\n    frequency=3000000.0,\n    level=0.5\n)\n</code></pre> <p>Create a new channel for a time-tag measurement.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>Channel number. A positive value corresponds to a timestamp event on a rising edge, a negative value corresponds to a timestamp event on a falling edge. See the manual from Swabian Instruments for more details.</p> required <code>deadtime</code> <code>int</code> <p>Dead time (in picoseconds) of the channel. The minimum dead time is defined by the internal clock period (which is 2000 ps for Time Tagger Ultra).</p> <code>2000</code> <code>delay</code> <code>int</code> <p>Additional delay (in picoseconds) to add to the timestamp of every event on this channel.</p> <code>0</code> <code>frequency</code> <code>float</code> <p>The expected maximum number of events (on this channel) per second during a measurement.</p> <code>3000000.0</code> <code>level</code> <code>float</code> <p>Signal level (in Volts) that, when exceeded, defines an event.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Channel</code> <p>A time-tag channel.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>@staticmethod\ndef create_channel(\n    number: int, *, deadtime: int = 2000, delay: int = 0, frequency: float = 3e6, level: float = 0.5\n) -&gt; Channel:\n    \"\"\"Create a new channel for a time-tag measurement.\n\n    Args:\n        number: Channel number. A positive value corresponds to a timestamp event on a rising edge,\n            a negative value corresponds to a timestamp event on a falling edge. See the manual from\n            Swabian Instruments for more details.\n        deadtime: Dead time (in picoseconds) of the channel. The minimum dead time is defined\n            by the internal clock period (which is 2000 ps for Time Tagger Ultra).\n        delay: Additional delay (in picoseconds) to add to the timestamp of every event on this channel.\n        frequency: The expected maximum number of events (on this channel) per second during a measurement.\n        level: Signal level (in Volts) that, when exceeded, defines an event.\n\n    Returns:\n        A time-tag channel.\n    \"\"\"\n    return Channel(number, deadtime=deadtime, delay=delay, frequency=frequency, level=level)\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.disconnect","title":"disconnect","text":"<pre><code>disconnect()\n</code></pre> <p>Stop all running measurements and release the TimeTagger object from memory.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Stop all running measurements and release the TimeTagger object from memory.\"\"\"\n    if not hasattr(self, \"_free_tagger\") or not hasattr(self, \"this\"):\n        return\n\n    self.stop()\n    if self._free_tagger:\n        TimeTagger.freeTimeTagger(self._tagger)\n        self._free_tagger = False\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.done","title":"done","text":"<pre><code>done()\n</code></pre> <p>Check if the measurement is done.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the measurement is done.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"Check if the measurement is done.\n\n    Returns:\n        Whether the measurement is done.\n    \"\"\"\n    return self._is_done\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start a measurement.</p> <p>This method does not block the calling routine. It will return as soon as the measurement is running.</p> See Also <p>wait</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start a measurement.\n\n    This method does not block the calling routine. It will return as\n    soon as the measurement is running.\n\n    See Also:\n        [wait][kibble.equipment.swabian_timetagger.TimeTag.wait]\n    \"\"\"\n    self._is_array_overflow = False\n    self._is_tagger_overflow = False\n    self._is_done = False\n    self._begin_time = -1\n    self._events = 0\n    self._tagger.clearOverflows()\n    self.clear()\n    super().start()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop a measurement.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop a measurement.\"\"\"\n    # Implemented so that this method appears in the documentation\n    super().stop()\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.tagger","title":"tagger","text":"<pre><code>tagger()\n</code></pre> <p>Return the time-tagger instance.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def tagger(self) -&gt; TimeTagger.TimeTagger:\n    \"\"\"Return the time-tagger instance.\"\"\"\n    return self._tagger\n</code></pre>"},{"location":"equipment/swabian_timetagger/#kibble.equipment.swabian_timetagger.TimeTagTriggered.wait","title":"wait","text":"<pre><code>wait(*, timeout=None)\n</code></pre> <p>Wait until the measurement is done.</p> <p>This is a blocking call and will not return until the measurement finishes or there is an error.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait for the measurement to be done. If <code>None</code>, wait forever.</p> <code>None</code> <p>Returns:</p> Type Description <code>Status</code> <p>The status when the measurement finished.</p> Source code in <code>src/kibble/equipment/swabian_timetagger.py</code> <pre><code>def wait(self, *, timeout: float | None = None) -&gt; Status:\n    \"\"\"Wait until the measurement is done.\n\n    This is a blocking call and will not return until the measurement finishes or there is an error.\n\n    Args:\n        timeout: The maximum number of seconds to wait for the measurement to be done.\n            If `None`, wait forever.\n\n    Returns:\n        The status when the measurement finished.\n    \"\"\"\n    t0 = perf_counter()\n    while True:\n        if self.done():\n            self.stop()\n            return Status(code=StatusCode.SUCCESS, message=\"Success\", success=True)\n\n        if (timeout is not None) and (perf_counter() - t0 &gt; timeout):\n            self.stop()\n            return Status(\n                code=StatusCode.TIMEOUT,\n                message=f\"Time-tag measurement timeout after {timeout} seconds\",\n                success=False,\n            )\n\n        if self._is_tagger_overflow:\n            self.stop()\n            return Status(code=StatusCode.OVERFLOW, message=\"TimeTagger has a buffer overflow\", success=False)\n\n        if self._is_array_overflow:\n            self.stop()\n            return Status(\n                code=StatusCode.OVERFLOW,\n                message=\"Buffered numpy array too small. Try one (or more) of the following:\\n\"\n                \"- Increase the expected frequency of a channel\\n\"\n                \"- Check that the voltage level for each channel is appropriate for the noise in the signal\\n\"\n                \"- For a gated measurement, increase the expected measurement duration\",\n                success=False,\n            )\n\n        sleep(0.01)\n</code></pre>"}]}